#### **Construcción de máquinas de Turing**


En esta práctica, implementaremos y simularemos Máquinas de Turing en Python. La idea es poder construir una máquina para un lenguaje determinado, definir sus transiciones, y simular paso a paso cómo se comporta al procesar una palabra.

Veremos cómo:

- Definir estados y transiciones.
- Procesar una palabra letra por letra.
- Mostrar en consola la evolución de la cinta y de la cabeza lectora.

##### **Ejemplo 0: Máquina de Turing para $L =\{a^n ~ |~ n \geqslant 0\}$.**

**Descripción del problema:**  
Queremos construir una máquina de Turing que acepte todas las palabras formadas únicamente por letras `a`, siempre que haya al menos una.

**Objetivo**
- Marcar los símbolos a con X para llevar control.
- Avanzar hacia la derecha hasta el espacio en blanco.
- Rechazar si encuentra algún símbolo no válido.
- Rechazar si la cinta está vacía.
"""

# Máquina de Turing para L = { a^n | n ≥ 0 }

transiciones = {
    ('q0', 'a'): ('q0', 'X', 'R'),
    ('q0', ' '): ('q_acept', ' ', 'R'),
}

estado_inicial = 'q0'
estado_aceptacion = 'q_acept'
estado_rechazo = 'q_rech'

def simular_mt(palabra):
    cinta = list(palabra) + [' ']  # agregamos espacio en blanco
    cabeza = 0
    estado = estado_inicial
    pasos = 0

    print(f"{'Paso':<5} {'Estado':<10} {'Cinta':<30} {'Cabeza'}")
    while estado != estado_aceptacion and estado != estado_rechazo:
        simbolo = cinta[cabeza]
        clave = (estado, simbolo)

        if clave not in transiciones:
            estado = estado_rechazo
            break

        nuevo_estado, nuevo_simbolo, direccion = transiciones[clave]
        cinta[cabeza] = nuevo_simbolo
        estado = nuevo_estado

        print(f"{pasos:<5} {estado:<10} {''.join(cinta):<30} {cabeza}")
        pasos += 1

        if direccion == 'R':
            cabeza += 1
            if cabeza == len(cinta):
                cinta.append(' ')
        elif direccion == 'L':
            cabeza = max(0, cabeza - 1)

    print("\nResultado:", "✅ Aceptada" if estado == estado_aceptacion else "❌ Rechazada")

simular_mt("a")     # ✅
simular_mt("aaa")   # ✅
simular_mt("")      # ❌
simular_mt("aab")   # ❌

"""##### **Ejercicio 1: Máquina de Turing para $L=\{a^mb^n ~ | ~ m\geqslant 1, n \text{ par}\}$**

**Descripción del problema**  
Queremos diseñar una máquina de Turing que acepte todas las palabras que:

- Comienzan con al menos una letra `a` (es decir, $m\geqslant 1$),
- Seguidas de una cantidad par de letras `b` (es decir, $n\in\{0,2,4,6,\ldots\}$).

**Objetivos**  
- Verificar que la palabra tenga al menos una `a`.
- Saltar por todas las `a` sin modificarlas.
- Verificar si la cantidad de `b` es par (marcando de dos en dos).
- Aceptar si cumple ambas condiciones.

**Instrucciones**
1. Copiá el código del ejemplo anterior como base.
2. Definí las transiciones necesarias para simular el comportamiento de esta máquina.
3. Asegurate de rechazar palabras vacías o que tengan cantidad impar de b.
4. Probá tu implementación con las siguientes palabras:

```python
# Palabras de prueba:
simular_mt("ab")        # ❌ (cantidad impar de b)
simular_mt("abb")       # ✅
simular_mt("aabbbb")    # ✅
simular_mt("aabbb")     # ❌
simular_mt("aaa")       # ✅
simular_mt("a")         # ✅
simular_mt("")          # ❌
```
"""

transiciones = {
    # q0: Verificar que la palabra empiece con 'a' y pasar a saltar 'a's
    ('q0', 'a'): ('q1', 'A', 'R'),     # Lee 'a', pasa a q1 para continuar verificando 'a',
                                       # mueve a la derecha, pasa a q1 () esto verifica m >= 1


    # q1: Saltar todas las 'a's
    ('q1', 'a'): ('q1', 'A', 'R'),      # Sigue procesando 'a's
    ('q1', 'b'): ('q2', 'B', 'R'),      # Cuando encuentra una 'b', pasa a q2 para buscar la segunda b (n debe ser par)
    ('q1', ' '): ('q_acept', ' ', 'R'), # Encuentra espacio (n=0 'b's es par), acepta (ya verificó m >= 1 'a's)

    # q2: Marcar la primera 'b' de un par
    ('q2', 'b'): ('q3', 'B', 'R'),      # Marca la segunda 'b' con 'B',  pasa a q3 para verificar mas 'b' o final de cadena

    ('q3', 'b'): ('q2', 'B', 'R'),      # Encuentra una 'b', pasa a q2 para buscar la segunda b
    ('q3', ' '): ('q_acept', ' ', 'R'), # Encuentra espacio  fin de la cadena luego d enumero par de 'b's

  }

estado_inicial = 'q0'
estado_aceptacion = 'q_acept'
estado_rechazo = 'q_rech'

def simular_mt(palabra):
    cinta = list(palabra) + [' ']
    cabeza = 0
    estado = estado_inicial
    pasos = 0

    print(f"\n--- Simulación para '{palabra}' ---")
    ##print(f"{'Paso':<5} {'Estado':<15} {'Cinta':<30} {'Cabeza'}")
    while estado != estado_aceptacion and estado != estado_rechazo:
        simbolo = cinta[cabeza]
        clave = (estado, simbolo)

        if clave not in transiciones:
            estado = estado_rechazo
            break

        nuevo_estado, nuevo_simbolo, direccion = transiciones[clave]
        cinta[cabeza] = nuevo_simbolo
        estado = nuevo_estado

        # Expande la cinta si la cabeza va más allá del final actual
        if direccion == 'R' and cabeza == len(cinta) - 1:
            cinta.append(' ')
        elif direccion == 'L' and cabeza == 0 and len(cinta) > 1: # Si va a la izquierda del inicio, puede añadir espacio por delante
            cinta.insert(0, ' ')
            cabeza = 0 # La cabeza sigue en la posición lógica de inicio

        #print(f"{pasos:<5} {estado:<15} {''.join(cinta):<30} {cabeza}")
        pasos += 1

        if direccion == 'R':
            cabeza += 1
        elif direccion == 'L':
            cabeza = max(0, cabeza - 1) # Asegura que la cabeza no baje de 0

    print("\nResultado:", "✅ Aceptada" if estado == estado_aceptacion else "❌ Rechazada")

# Palabras de prueba:
simular_mt("ab")         # ❌ (cantidad impar de b)
simular_mt("abb")        # ✅
simular_mt("aabbbb")     # ✅
simular_mt("aabbb")      # ❌
simular_mt("aaa")        # ✅ (n=0, par)
simular_mt("a")          # ✅ (n=0, par)
simular_mt("")           # ❌ (m >= 1)

"""#####**Ejercicio 2 - Una máquina de Turing especial**

**Descripción del problema**  
Diseñá una máquina de Turing que acepte el lenguaje:
$$L=\{w\in\{a,b\}^* ~\mid \text{ la palabra contiene la misma cantidad de $a$ y $b$}\}.$$

Ejemplos aceptados: `"ab"`, `"ba"`, `"aabb"`, `"abab"`, `"baba"`, `"abba"`  
Ejemplos rechazados: `"aab"`, `"b"`, `"aaabbb"`, `"abbba"`

**Objetivos**
- Manipular símbolos marcados (por ejemplo `X`, `Y`) para contar pares.
- Simular un contador lógico sin necesidad de usar una pila.
- Aplicar técnicas de recorrido en dos sentidos.

**Instrucciones**  
1. Especificá los estados y transiciones para lograr marcar cada `a` con un `X`, y emparejarla con un `b` (marcado como `Y`) en el mismo orden.
2. Repetí hasta que no queden más símbolos sin marcar.
3. Aceptá si la cinta contiene solo `X`, `Y` y blancos al final.

**Nota**: Podés inspirarte en los ejercicios de la lista teórica.
"""

transiciones = {
    # q0:
    ('q0', 'a'): ('q1a', 'A', 'R'),     # Lee 'a', se mueve a la derecha y pasa a q1a que buscara una 'b' para emparejar
    ('q0', 'b'): ('q1b', 'B', 'R'),     # Lee 'b', se mueve a la derecha y pasa a q1b que buscara una 'a' para emparejar
    ('q0', 'A'): ('q0','A','R'),        # omite ya marcados
    ('q0', 'B'): ('q0','B','R'),        # omite ya marcados
    ('q0', ' '): ('q_acept', ' ', 'R'), # Encuentra espacio, fin de la cadena


    # q1a (busca si existe un a'b' sin marcar para emparejar una lectura previa de una A)
    ('q1a', 'a'): ('q1a', 'a', 'R'), # Omite a's
    ('q1a', 'B'): ('q1a', 'B', 'R'), # Omite caracteres ya marcados
    ('q1a', 'A'): ('q1a', 'A', 'R'), # Omite caracteres ya marcados
    ('q1a', 'b'): ('q2', 'B', 'L'),  # Encuentra una 'b', marca y va a q2

    ('q1b', 'a'): ('q2', 'A', 'L'),  # Encuentra una 'a', marca y va a q2
    ('q1b', 'A'): ('q1b', 'A', 'R'), # Encuentra una 'b', marca y va a q2
    ('q1b', 'B'): ('q1b', 'B', 'R'), # Encuentra una 'b', marca y va a q2
    ('q1b', 'b'): ('q1b', 'b', 'R'), # Omite b's

    # q2: retrocede hasta el inicio de la cinta
    ('q2', 'a'): ('q2', 'a', 'L'),
    ('q2', 'b'): ('q2', 'b', 'L'),
    ('q2', 'A'): ('q2', 'A', 'L'),
    ('q2', 'B'): ('q2', 'B', 'L'),
    ('q2', ' '): ('q0', ' ', 'R'), # llega al comienzo de la cinta, se mueve a la derecha y salta a q0
  }

estado_inicial = 'q0'
estado_aceptacion = 'q_acept'
estado_rechazo = 'q_rech'

def simular_mt(palabra):
    cinta =  [' '] + list(palabra) + [' ']
    cabeza = 1
    estado = estado_inicial
    pasos = 0

    print(f"\n--- Simulación para '{palabra}' ---")
    ##print(f"{'Paso':<5} {'Estado':<15} {'Cinta':<30} {'Cabeza'}")
    while estado != estado_aceptacion and estado != estado_rechazo:
        simbolo = cinta[cabeza]
        clave = (estado, simbolo)

        if clave not in transiciones:
            estado = estado_rechazo
            break

        nuevo_estado, nuevo_simbolo, direccion = transiciones[clave]
        cinta[cabeza] = nuevo_simbolo
        estado = nuevo_estado

        # Expande la cinta si la cabeza va más allá del final actual
        if direccion == 'R' and cabeza == len(cinta) - 1:
            cinta.append(' ')
        elif direccion == 'L' and cabeza == 0 and len(cinta) > 1: # Si va a la izquierda del inicio, puede añadir espacio por delante
            cinta.insert(0, ' ')
            cabeza = 0 # La cabeza sigue en la posición lógica de inicio

        #print(f"{pasos:<5} {estado:<15} {''.join(cinta):<30} {cabeza}")
        pasos += 1

        if direccion == 'R':
            cabeza += 1
        elif direccion == 'L':
            cabeza = max(0, cabeza - 1) # Asegura que la cabeza no baje de 0

    print("\nResultado:", "✅ Aceptada" if estado == estado_aceptacion else "❌ Rechazada")

palabras = ["ab", "ba", "aabb", "abab", "baba", "abba", "aab", "b", "aaabbb", "abbba"]
for palabra in palabras:
      simular_mt(palabra)

"""#####**Ejercicio 3 — Máquina de Turing para $L=\{ww ~ ∣ ~w\in \{0,1\}^∗ \}$ (mucho más difícil)**

**Descripción del problema**  
Queremos diseñar una máquina de Turing que acepte las palabras que son la concatenación exacta de un bloque consigo mismo.  
Ejemplos válidos:
- `0101`, `001001`, `11`, `00`, `1010`, `110110`

Ejemplos inválidos:
- `010`, `001`, `10`, `111`, `1001`

**Instrucciones**  
1. Utilizá una estrategia de comparación iterativa (Ver párrafo al final).
2. Probá tu simulación con los siguientes ejemplos:

```python
# Palabras de prueba:
simular_mt("01")        # ❌
simular_mt("0101")      # ✅
simular_mt("001001")    # ✅
simular_mt("1010")      # ✅
simular_mt("111")       # ❌
simular_mt("110110")    # ✅
simular_mt("1001")      # ❌
```

**⚠️ Importante**  
Este ejercicio es considerablemente más complejo que los anteriores.
Por eso, se considera **opcional** y puede ser reemplazado por una reflexión escrita que proponga una estrategia general para resolver el problema.

**📝 Estrategia sugerida**  
Una estrategia válida consiste en usar un **símbolo blanco (`␣`) como marcador móvil (o un símbolo especial como `#`)**.

Este marcador se desplaza desde el final de la cinta hacia la izquierda, delimitando progresivamente las dos partes de la palabra.

- Si todos los pares coinciden y el marcador llega al centro de la cadena: la palabra es **aceptada**.

✅ La reflexión puede ser breve pero debe dejar claro cómo se verifica una palabra.
"""

from tabulate import tabulate

transiciones = {
    # Las transiciones se dividieron en 2 "pasos" el primero busca poner el caracter '|' en el "centro" de la cadena
    # El siguiente paso busca comparar caracter a caracter las cadenas a ambos lados del caracter de separacion '|'

             #######################################################################
             # Aca comienza las transciciones del PASO 1
             #######################################################################

             # q0 procesa el primer caracter NO PROCESADO, cuando encuentra
             ('q0', '0'): ('q1', 'A', 'R'),   # marca con A los 0's procesados para luego poder revertir el cambio para el paso 2
             ('q0', '1'): ('q1', 'B', 'R'),   # marca con B los 0's procesados para luego poder revertir el cambio para el paso 2
             ('q0', '|'): ('q6', '|', 'R'),   # cuando el siguiente caracter a procesar es | es porque la marca de separacion ya
                                              # esta en el medio de la cadena

             # q1 busca la posicion del caracter | , si no lo encuentra avanza a la derecha sin realizar cambios
             ('q1', '1'): ('q1', '1', 'R'),
             ('q1', '0'): ('q1', '0', 'R'),
             ('q1', '|'): ('q3', '|', 'L'),   # cuando lo encuentra, retrocede

             # q3 lee el caracter anterior a la ultima posicion del caracter de separacion
             ('q3', '0'): ('q3_0', '|', 'R'), # cuando encuentra un 0 cambia el caracter por | y pasa al estado q3_0 y se mueve a la derecha
                                              # que es la ultima posicion "anterior" del caracter |
             ('q3', '1'): ('q3_1', '|', 'R'), # cuando encuentra un 1 cambia el caracter por | y pasa al estado q3_1 y se mueve a la derecha
                                              # que es la ultima posicion "anterior" del caracter |


             ('q3_0', '|'): ('q4', '0', 'L'), # sustituye la posicion anterior del caracter | por el 0 leido en el estado q3, Salta a q4
             ('q3_1', '|'): ('q4', '1', 'L'), # sustituye la posicion anterior del caracter | por el 1 leido en el estado q3, Salta a q4

             # q4 retrocede hasta encontrar una A o una B que es el caracter procesado en la "primer mitad" de la palabra
             # NOTA : Los caracteres de la segunda mitad no se cambian al encontrarlos
             ('q4', '0'): ('q4', '0', 'L'),
             ('q4', '1'): ('q4', '1', 'L'),
             ('q4', '|'): ('q4', '|', 'L'),
             ('q4', 'A'): ('q0', 'A', 'R'), # cuando encuentra una A o una B pasa al estado q0 luego de moverse a la derecha
             ('q4', 'B'): ('q0', 'B', 'R'), # porque se encuentra en el primer caracter "no procesado"

             # q5 busca el final de la cinta moviendose hacia la derecha sin modificar nada
             # (q5 inicia en el primer cracter de la segunda mitad del algoritmo)
  #           ('q5', '0'): ('q5', '0', 'R'),
  #           ('q5', '1'): ('q5', '1', 'R'),
  #           ('q5', '|'): ('q5', '|', 'R'),
  #           ('q5', ' '): ('q6', ' ', 'L'), # cuando llega la final de la cinta pasa a q6

             # q6 deja la cinta en el estado original revirtiendo los cambios de A por 0 y B por 1
             # omitiendo cualquier otro caracter, lo hace desde el final de la cinta hacia el  comienzo moviendose a la izquierda
             ('q6', '0'): ('q6', '0', 'L'), # si el caracter esta en la segunda mitad es un 0 lo ignora
             ('q6', 'B'): ('q6', '1', 'L'), # si el caracter esta en la primer mitad es un B lo convierte en 1
             ('q6', '1'): ('q6', '1', 'L'), # si el caracter esta en la segunda mitad es un 1 lo ignora
             ('q6', 'A'): ('q6', '0', 'L'), # si el caracter esta en la primer mitad es un A lo convierte en 0
             ('q6', '|'): ('q6', '|', 'L'),
             ('q6', ' '): ('q02', ' ', 'R'),  # cuando llega al comienzo de la cinta salta a q02 (el estado "inicial" del siguiente paso del algoritmo )


             ####################################################################################################
             # Aca comienza las transciciones del PASO 2 - Verificacion que ambas mitades de la cinta son iguales
             ####################################################################################################

             #q02 es el "estado inicial" de la segunda mitad del algoritmo
             ('q02', '|'): ('q_acept', ' ', 'R'),   # si debe validar | esta en mitad de la palabra y la acepta
             ('q02', ' '): ('q_acept', ' ', 'R'),   # si debe validar ' ' (es la palabra vacia), la concatenacion de "" y "" es una palabra valida
             ('q02', '0'): ('q12_0', 'A', 'R'),     # marca el 0 como procesado y dalta a q12_0 (que buscara el 0 luego del caracter |)
             ('q02', '1'): ('q12_1', 'B', 'R'),     # marca el 1 como procesado y dalta a q12_1 (que buscara el 1 luego del caracter |)


             # q12_0 busca el caracter |
             ('q12_0', '0'): ('q12_0', '0', 'R'),  # el resto de la primer mitad de la palabra aun sin procesar
             ('q12_0', '1'): ('q12_0', '1', 'R'),  # el resto de la primer mitad de la palabra aun sin procesar
             ('q12_0', '|'): ('q22_0', '|', 'R'),  # encontro la mitad de la palabra, ahora debe buscar el primer 0 sin procesar

             # q12_1 busca el caracter |
             ('q12_1', '0'): ('q12_1', '0', 'R'), # el resto de la primer mitad de la palabra aun sin procesar
             ('q12_1', '1'): ('q12_1', '1', 'R'), # el resto de la primer mitad de la palabra aun sin procesar
             ('q12_1', '|'): ('q22_1', '|', 'R'), # encontro la mitad de la palabra, ahora debe buscar el primer 1 sin procesar

             # q22_0 buscara el primer 0 luego de la marca de mitad de la palabra
             ('q22_0', '0'): ('q32', 'A', 'L'),    # el primer caracter luego de los ya procesados es 0, lo marca y pasa a q32
             ('q22_0', 'A'): ('q22_0', 'A', 'R'),  # omite caracteres ya procesados
             ('q22_0', 'B'): ('q22_0', 'B', 'R'),  # omite caracteres ya procesados

             # q22_1 buscara el primer 1 luego de la marca de mitad de la palabra
             ('q22_1', '1'): ('q32', 'B', 'L'),    # el primer caracter luego de los ya procesados es 1, lo marca y pasa a q32
             ('q22_1', 'B'): ('q22_1', 'B', 'R'),  # omite caracteres ya procesados
             ('q22_1', 'A'): ('q22_1', 'A', 'R'),  # omite caracteres ya procesados


             # q32 retrocede hasta la marca de mitad de la palabra
             ('q32', 'A'): ('q32', 'A', 'L'),
             ('q32', 'B'): ('q32', 'B', 'L'),
             ('q32', '|'): ('q42', '|', 'L'),  # encuentra la mitad de la palabra al moverse a la izquierda y salta al estado q42

             # q42 buscara el ultimo caracter PROCESADO (A o B) en la primer mitad de la palabra
             ('q42', '0'): ('q42', '0', 'L'), # omite los 0 porque no se han procesado
             ('q42', '1'): ('q42', '1', 'L'), # omite los 1 porque no se han procesado
             ('q42', 'A'): ('q02', 'A', 'R'), # encuentra el ultimo caracter que ya porceso y vuelve al estado "inicial" del seguno paso q02
             ('q42', 'B'): ('q02', 'B', 'R'), # encuentra el ultimo caracter que ya porceso y vuelve al estado "inicial" del seguno paso q02
}
estado_inicial = 'q0'
estado_aceptacion = 'q_acept'
estado_rechazo = 'q_rech'

def simular_mt(palabra):
    tabla = []

    cinta = [' '] + list(palabra) + ['|'] + [' ']     ####################### La cinta se carga con ' ' + palabra + '|' + ' '
    cabeza = 1                                        # La máquina de Turing empieza desde la posición 1 (el primer carácter de la palabra).
    estado = estado_inicial
    pasos = 0


    while estado != estado_aceptacion and estado != estado_rechazo:
        if pasos > 1000:
            tabla.append([" ","Bucle", "detectado","Abortando.", '','',''])
            break
        simbolo = cinta[cabeza]
        viejo_estado = estado
        clave = (estado, simbolo)

        if clave not in transiciones:
            estado = estado_rechazo
            break
        nuevo_estado, nuevo_simbolo, direccion = transiciones[clave]
        cinta_vieja = ''.join(cinta)
        cinta[cabeza] = nuevo_simbolo
        estado = nuevo_estado
        tabla.append([pasos,viejo_estado, cinta_vieja,cabeza,simbolo,nuevo_simbolo,nuevo_estado,direccion])
        pasos += 1

        if direccion == 'R':
            cabeza += 1
            if cabeza == len(cinta):
                cinta.append(' ')
        elif direccion == 'L':
            cabeza = max(0, cabeza - 1)


    resultado = " ✅ Aceptada" if estado == estado_aceptacion else " ❌ Rechazada"
    tabla.append(['Resultado:' ,'',resultado,'','','','',''])
    return tabla, resultado


# Palabras de prueba:
palabras = ["01","0101","001001","1010","111","110110","1001","", "123", "10101010"]
encabezados = ['Paso', 'Estado' ,'Cinta', 'Cabeza', 'Lee', 'Escribe', 'Estado N', 'Direccion']
mostrar_tabla = input('Mostrar tabla de transiciones (S/N):')
for palabra in palabras:
  resultados,resumen = simular_mt(palabra)
  print(f"Simulando {palabra}: {resumen}")
  ## print(resultados)
  if mostrar_tabla == 'S' or mostrar_tabla =='s':
      print(tabulate(resultados, headers=encabezados, tablefmt = "double_grid", numalign="center", stralign="center"))
      siguiente = input('Siguiente')



