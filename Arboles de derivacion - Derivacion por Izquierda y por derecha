"""#### **Derivaci√≥n izquierda y derecha**

Existen dos formas de aplicar las reglas de producci√≥n de una gram√°tica:

‚úÖ Derivaci√≥n por la izquierda: Siempre se sustituye el s√≠mbolo no terminal m√°s a la izquierda.

‚úÖ Derivaci√≥n por la derecha: Siempre se sustituye el s√≠mbolo no terminal m√°s a la derecha.

El tipo de derivaci√≥n afecta la construcci√≥n de los √°rboles de derivaci√≥n.

##### **Ejemplo 2: Implementaci√≥n de derivaci√≥n izquierda y derecha**

**Descripci√≥n del problema:**

Queremos construir una palabra a partir de una gram√°tica aplicando dos estrategias diferentes: derivaci√≥n izquierda y derivaci√≥n derecha.

**Objetivo:**
- Implementar la derivaci√≥n de una palabra de forma determinada por el orden de sustituci√≥n.
- Comparar los resultados obtenidos con derivaci√≥n izquierda y derecha.

**Gram√°tica dada:**
- $G = (\{S, A\}, \{a, b\}, S, \{S \to aAS\, |\, a, A \to Ab\,|\,b\})$
- Generar la palabra "$aba$".

**Entradas**
1. Un s√≠mbolo inicial S.
2. Reglas de producci√≥n de la gram√°tica.
3. Estrategia de derivaci√≥n (izquierda o derecha).

**Salidas**
1. Secuencia de pasos en la derivaci√≥n.

**Ejemplo de salida esperada:**
- Derivaci√≥n por la izquierda:
```yaml
Paso 1: S
Paso 2: aAS
Paso 3: abS
Paso 4: aba
```
- Derivaci√≥n por la derecha:
```yaml
Paso 1: S
Paso 2: aAS
Paso 3: aAa
Paso 4: aba   
```
"""

----------------------------------------------------
## An√°lisis del c√≥digo de derivaci√≥n y propuestas de mejora

### üîç Limitaciones identificadas
1. **Falta de control de cadenas repetidas**
   El c√≥digo no verifica si una cadena ya fue procesada, lo que puede causar:
   - Bucles infinitos en gram√°ticas recursivas
   - Procesamiento redundante de las mismas cadenas

2. **Restricci√≥n de longitud prematura**
   La condici√≥n `len(nueva_cadena) <= len(palabra_objetivo)` bloquea derivaciones v√°lidas que requieren pasos intermedios largos (comunes en gram√°ticas con producciones √©psilon).

3. **Orden de expansi√≥n ineficiente**
   Al expandir siempre el primer no-terminal de izquierda a derecha, podr√≠a perderse derivaciones m√°s eficientes.

### üß™ Caso de prueba problem√°tico
**Gram√°tica modificada:**
```python
gramatica_epsilon = {
    "S": ["aA"],
    "A": ["a", ""]  # Producci√≥n √©psilon (cadena vac√≠a)
}
```
**Objetivo:** `"a"`
**Comportamiento actual:** No encuentra la derivaci√≥n `S ‚Üí aA ‚Üí a`

### üí° Propuestas de soluci√≥n
1. **A√±adir conjunto de visitados**
   Evitar reprocesar cadenas ya exploradas:
   ```python
   def derivacion_mejorada(simbolo_inicial, reglas, palabra_objetivo):
       visitados = set()
       fila = deque([(simbolo_inicial, [simbolo_inicial])])
       visitados.add(simbolo_inicial)

       while fila:
           actual, pasos = fila.popleft()

           if actual == palabra_objetivo:
               return pasos

           for i, simbolo in enumerate(actual):
               if simbolo in reglas:
                   for produccion in reglas[simbolo]:
                       nueva = actual[:i] + produccion + actual[i+1:]
                       if nueva not in visitados:
                           visitados.add(nueva)
                           fila.append((nueva, pasos + [nueva]))
       return []
   ```

2. **Eliminar restricci√≥n de longitud**
   Permitir cadenas m√°s largas que el objetivo:
   ```python
   # Eliminar esta l√≠nea:
   if len(nueva_cadena) <= len(palabra_objetivo):
   ```

3. **Implementar b√∫squeda en profundidad (DFS) controlada**
   Para gram√°ticas con derivaciones largas pero necesarias:
   ```python
   def derivacion_dfs(simbolo, reglas, objetivo, max_profundidad=10):
       pila = [(simbolo, [simbolo], 0)]

       while pila:
           actual, pasos, profundidad = pila.pop()
           if actual == objetivo:
               return pasos
           if profundidad < max_profundidad:
               # Expansi√≥n inversa (para priorizar ciertas reglas)
               for i in reversed(range(len(actual))):
                   if actual[i] in reglas:
                       for prod in reversed(reglas[actual[i]]):
                           nueva = actual[:i] + prod + actual[i+1:]
                           pila.append((nueva, pasos + [nueva], profundidad + 1))
       return []
   ```

### üìä Comparativa de enfoques
| Enfoque       | Ventajas                      | Desventajas               |
|---------------|-------------------------------|---------------------------|
| BFS original  | Encuentra la derivaci√≥n m√°s corta | No maneja recursi√≥n infinita |
| BFS + visitados| Evita ciclos infinitos        | Mayor uso de memoria       |
| DFS controlado| Mejor para derivaciones largas | Puede perder caminos cortos |

### ‚úÖ Implementaci√≥n recomendada
La versi√≥n mejorada combinando BFS con visitados y sin restricci√≥n de longitud:
```python
from collections import deque

def derivacion_optimizada(simbolo_inicial, reglas, palabra_objetivo):
    visitados = set()
    fila = deque([(simbolo_inicial, [simbolo_inicial])])
    visitados.add(simbolo_inicial)

    while fila:
        actual, pasos = fila.popleft()

        if actual == palabra_objetivo:
            return pasos

        for i in range(len(actual)):
            simbolo = actual[i]
            if simbolo in reglas:
                for produccion in reglas[simbolo]:
                    nueva = actual[:i] + produccion + actual[i+1:]
                    if nueva not in visitados:
                        visitados.add(nueva)
                        fila.append((nueva, pasos + [nueva]))

    print("Derivaci√≥n no encontrada")
    return []
```

Este enfoque:
1. Maneja producciones √©psilon correctamente
2. Evita ciclos infinitos
3. Mantiene la completitud de BFS
4. Reduce significativamente el espacio de b√∫squeda

**Ejemplo de uso exitoso:**
```python
gramatica = {
    "S": ["aAb", "aaAb"],
    "A": ["aabbA", "ba"]
}

print(derivacion_optimizada("S", gramatica, "abab"))
# Salida: ['S', 'aAb', 'abab']
```

### Corte prematuro.. se debe evaluar el largo de la palabra excluyendo los simbolos no terminales en la misma
### Evaluar las palabras hasta los simbolos no terminales
### Ejemplo aAb o bSab nunca podra generar la palabra bba porque las posiciones de las letras en la misma no coinciden
### Guardar un registro de cadenas ya procesadas par ano caer en loops infinitos
### Al evaluar siempre la expansion por derecha, se pueden perder expansiones mas eficientes de la palabra

"""##### **Ejercicio 3 - Desaf√≠o: Mejorando el c√≥digo**

**Descripci√≥n del problema:**

El c√≥digo que acabamos de ver permite realizar derivaciones de una palabra con estrategias izquierda o derecha. Sin embargo, como cualquier implementaci√≥n, existen m√∫ltiples formas de mejorarlo y hacer que sea m√°s flexible y poderoso.

Este es un ejercicio abierto, donde no hay una √∫nica respuesta correcta. Queremos que explores el c√≥digo, identifiques sus limitaciones y pienses en posibles mejoras. Lo m√°s importante aqu√≠ es el proceso de an√°lisis y razonamiento.

üìå Tu tarea es investigar y proponer mejoras en el c√≥digo. Puedes enfocarte en cualquier aspecto que consideres relevante.
"""

