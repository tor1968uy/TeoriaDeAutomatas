"""##### **Ejercicio 1: Simulaci贸n de un PDA para pal铆ndromos de longitud par**

**Descripci贸n del problema:**

Queremos simular un aut贸mata de pila (PDA) que acepte el lenguaje
$$L=\{ww^r| w\in \{0,1\}, w^r \text{ es la reversa exacta de } w\}$$

**Objetivo:**

Implementar un PDA que:
- Empila los s铆mbolos de la primera mitad de la palabra.
- Luego, desapila y compara con la segunda mitad.
- Acepta si la pila queda vac铆a y se alcanza el estado final.

**Definici贸n del PDA:**
- Estados: $Q= \{q_1, q_2, q_3, q_4 \}$
- Alfabeto de entrada: $\Sigma = \{ 0,1\}$
- Alfabeto de pila: $\Gamma =\{0,1,\$ \}$
- Estado inicial: $q_1$
- S铆mbolo inicial de pila: $\varepsilon$
- Estado final: $q_4$
- Aceptaci贸n: por estado final o pila vac铆a

**Transiciones:**
$$(q_1, \varepsilon,\varepsilon) \to (q_2, $)$$
$$(q_2, 0,\varepsilon) \to (q_2, 0)$$
$$(q_2, 1,\varepsilon) \to (q_2, 1)$$
$$(q_2, \varepsilon,\varepsilon) \to (q_3, \varepsilon)$$
$$(q_3, 0, 0) \to (q_3, \varepsilon)$$
$$(q_3, 1, 1) \to (q_3, \varepsilon)$$
$$(q_3, \varepsilon, $) \to (q_4, \varepsilon)$$

**Instrucciones:**
- Implementa este PDA en Python utilizando una pila (lista).
- Simula el comportamiento paso a paso, diferenciando claramente las fases de apilamiento y desapilamiento.
- Verifica con ejemplos como: `"0110"`, `"1010"`, `"010"`, `"1001"` y otros.
"""



"""##### **Ejemplo 2 - Simulaci贸n de un PDA usando transiciones declaradas (estilo NFA)**

**Descripci贸n del problema:**

Queremos construir un simulador general de aut贸matas de pila no deterministas (PDA), donde las transiciones est茅n definidas por una estructura externa (diccionario), separando la l贸gica del aut贸mata de la simulaci贸n.

Simularemos un PDA que acepta el lenguaje:
$$ L = \{ a^nb^n | n\geqslant 1  \}. $$

**Definici贸n del PDA:**
- Estados: $\{q_0,q_1\}$
- Alfabeto de entrada: $\{a,b\}$
- Alfabeto de pila: $\{A\}$
- Estado inicial: $q_0$
- Estados de aceptaci贸n: $\{q_1\}$
- Aceptaci贸n por pila vac铆a

**Transiciones:**
$$(q_0, a,\varepsilon) \to (q_0, A)$$
$$(q_0, b,A) \to (q_1, \varepsilon)$$
$$(q_1, b,A) \to (q_1, \varepsilon)$$

** Objetivo:**
- Representar las transiciones como diccionario.
- Simular el PDA con pila.
- Explorar m煤ltiples caminos posibles (no determinismo).
- Aceptar la palabra si al menos una ejecuci贸n termina con pila vac铆a en estado final.
"""

def simular_pda(est_inicial, est_aceptacion, transiciones, palabra):
    # Cada configuraci贸n: (estado, 铆ndice de lectura, pila)
    configuraciones = [(est_inicial, 0, [])]

    while configuraciones:
        estado, i, pila = configuraciones.pop()

        if i == len(palabra) and not pila and estado in est_aceptacion:
            return True  # Aceptaci贸n por pila vac铆a en estado final

        simbolo = palabra[i] if i < len(palabra) else None
        tope = pila[-1] if pila else None

        # Buscar todas las transiciones posibles
        claves = [
            (estado, simbolo, tope),
            (estado, simbolo, None),
            (estado, None, tope),
            (estado, None, None)
        ]

        for clave in claves:
            if clave in transiciones:
                for (nuevo_estado, accion_pila) in transiciones[clave]:
                    nueva_pila = pila.copy()
                    if tope and clave[2] == tope:
                        nueva_pila.pop()
                    if accion_pila:
                        nueva_pila.append(accion_pila)
                    nuevo_i = i + 1 if clave[1] is not None else i
                    configuraciones.append((nuevo_estado, nuevo_i, nueva_pila))

    return False

# Definici贸n del aut贸mata:
transiciones = {
    ("q0", "a", None): [("q0", "A")],
    ("q0", "b", "A"): [("q1", None)],
    ("q1", "b", "A"): [("q1", None)],
}

estado_inicial = "q0"
estados_aceptacion = {"q1"}

palabras = ["ab", "aabb", "aaabbb", "aab", "abb"]

for w in palabras:
    print(f"{w} -> {simular_pda(estado_inicial, estados_aceptacion, transiciones, w)}")
