"""##### **Ejercicio 3 - Construcción de un NFA**

**Descripción del problema**

Ahora queremos modificar el programa para soportar un NFA, permitiendo que un estado tenga múltiples transiciones posibles para un mismo símbolo.

**Objetivo**
- Modificar la estructura de transiciones para permitir conjuntos de estados.

**Nuevas transaciones**

| Estado  | Entrada $0$ | Entrada $1$ |
| :-----: | :---------: | :---------: |
| $q_0$   |   $q_0, q_1$   | $q_0$ |
| $q_1$   |   $q_2$  | $q_1$ |
| $q_2$   |  $q_2$   | $q_2$ |

**Instrucciones:**
1. Modifica el código para representar transiciones como conjuntos de estados.
2. Usa un enfoque basado en listas de estados activos para simular la ejecución del NFA.
3. Verifica si al menos uno de los caminos llega a un estado de aceptación.
4. **Observa cómo ciertas palabras generan múltiples bifurcaciones innecesarias.** Por ejemplo, para la palabra `"0000001"`, el autómata se ramifica en varios estados, pero solo algunos caminos pueden llegar a un estado final. Analiza cómo esto introduce **complejidad innecesaria en el procesamiento**.
"""

def simular_nfa(estado_inicial, estados_aceptacion, transiciones, palabra):
    # Simula el procesamiento de una palabra en un NFA.
    # Args:
    #    estado_inicial (str): Estado inicial del NFA.
    #    estados_aceptacion (set): Conjunto de estados de aceptación.
    #    transiciones (dict): Función de transición (puede ser no determinista).
    #    palabra (str): Palabra a procesar.
    # Returns:
    #    str: "Aceptada" si al menos un camino lleva a aceptación, "Rechazada" en caso contrario.

    estados_actuales = {estado_inicial}  # Conjunto de estados actuales (puede haber varios)

    for simbolo in palabra:
        nuevos_estados = set()
        for estado in estados_actuales:
            if (estado, simbolo) in transiciones:
                nuevos_estados.update(transiciones[(estado, simbolo)])
        estados_actuales = nuevos_estados
        if not estados_actuales:  # Si no hay transiciones posibles
            return "Rechazada"

    # Verificar si al menos un estado actual es de aceptación
    return "Aceptada" if estados_actuales & estados_aceptacion else "Rechazada"

def validar_palabra(palabra, alfabeto):
    return all(simbolo in alfabeto for simbolo in palabra)

# Definición del NFA
estados = {"q0", "q1", "q2"}  # Estados posibles
alfabeto = {"0", "1"}          # Alfabeto permitido
estado_inicial = "q0"          # Estado inicial
estados_aceptacion = {"q2"}    # Estados de aceptación

# Función de transición no determinista (δ)
transiciones = {
    ("q0", "0"): {"q0", "q1"},  # Desde q0, con '0' puede ir a q0 o q1
    ("q0", "1"): {"q0"},        # Desde q0, con '1' solo puede ir a q0
    ("q1", "0"): {"q2"},        # Desde q1, con '0' va a q2
    ("q1", "1"): {"q1"},        # Desde q1, con '1' sigue en q1
    ("q2", "0"): {"q2"},        # Desde q2, con '0' sigue en q2
    ("q2", "1"): {"q2"}         # Desde q2, con '1' sigue en q2
}

# Ejemplos predefinidos
ejemplos = ["01", "001", "1101", "1001", "0000001"]
print("\n=== Pruebas Automáticas ===")
for ejemplo in ejemplos:
    if validar_palabra(ejemplo, alfabeto):
        resultado = simular_nfa(estado_inicial, estados_aceptacion, transiciones, ejemplo)
        print(f"'{ejemplo}' → {resultado}")
    else:
        print(f"'{ejemplo}' → Error: Contiene símbolos no válidos")

palabra = ' '
print("\n=== Modo Interactivo ===")
print("Ingrese palabras una por una. Presione Enter sin escribir para terminar.")
lista_palabras = []
while palabra != '':
   palabra = input("Ingrese una palabra: ")
   if palabra != '' :
      lista_palabras.append(palabra)

print("\n=== Resultados ===")
for i, palabra in enumerate(lista_palabras, 1):
    if validar_palabra(palabra, alfabeto):
        resultado = simular_nfa(estado_inicial, estados_aceptacion, transiciones, palabra)
        print(f"Palabra {i}: '{palabra}' → {resultado}")
    else:
        print(f"Palabra {i}: '{palabra}' → Error: Contiene símbolos no válidos")

"""Explicación de los Cambios

      1. Estructura de Transiciones No Determinista
Las transiciones ahora se modificaron para que apunten a conjuntos de estados (en lugar de un único estado).
Ejemplo:

       ("q0", "0"): {"q0", "q1"}  # Desde q0, con '0' puede ir a q0 o q1
 .

      2. Algoritmo de Simulación Basado en Conjuntos

estados_actuales almacena ahora todos los estados posibles en cada paso.

Para cada símbolo, se calculan los nuevos estados alcanzables desde el/los estados actuales.

Si en algún momento no hay transiciones posibles (estados_actuales vacío), la palabra es rechazada.

      3. Verificación de Aceptación
Al final del procesamiento, se verifica si al menos un estado actual está en estados_aceptacion.


El NFA puede generar múltiples caminos, lo que aumenta la complejidad computacional.

Ejemplo: Para "0000001", el autómata explora todas las combinaciones posibles de q0 y q1 antes de llegar (o no) a q2.

Optimización posible:

    1) Convertir el NFA a DFA (Autómata Finito Determinista) para reducir la complejidad.

    2) Usar memorización para evitar recalcular estados repetidos.

Conclusión:

    El código ahora soporta no determinismo, permitiendo múltiples transiciones.

    Evalúa correctamente si al menos un camino lleva a aceptación.

Ineficiencias:

    En palabras largas, el número de estados activos puede crecer exponencialmente.

Recomendación:

    Para mejorar el rendimiento, considerar una conversión a DFA o técnicas de "poda de estados inalcanzables".

    Implementar una versión con backtracking para explorar solo caminos prometedores.

Este simulador cumple con el objetivo de manejar NFA y verificar aceptación de palabras.
